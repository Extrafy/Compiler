# BUAA-2024Autume-Compiler

> Extrafy

这里是**北航2024年秋季学期 编译课程的实验课程作业代码**

源程序语言是课程组要求的SysY，中间代码为LLVM，目标代码为mips

中端实现了一些简单的循环检测，死代码删除，运算强度递减优化，由于时间原因没有实现Mem2Reg优化。~~其实是自己太菜~~

后端使用了图着色寄存器分配，少量窥孔优化。

**最终竞速排序 44 名**

什么？没看见**最终代码**？全在master分支里！！！

想分开看每一部分的代码？在每部分对应的分支里！！！

什么？没看见平时作业？全在Homework分支里！！！

如果有疑问联系作者发现他一直不回，那就是 ~~作者也不知道怎么做~~ 作者很忙没看见消息

### 1. 一些建议

编译课程分为理论和实验两部分，理论占60%，实验占40%

对于理论课，主要分数来源于作业、小测和期末考试。期末考试占理论部分的60%。平时作业一定要按时完成，课堂考勤去不去视老师而定，**但小测一定要认真对待！！！**（期末莫名因为小测扣2，3分很不值）。小测随机进行，是开卷的，可以查看ppt和书，和同学小声讨论也是被默许的（只要别太嚣张

对于实验课，在开始之前借鉴往届学长学姐的代码是很有必要的（即使你是大神，请也要多参考），一般来说每年的课下实验会修改一些文法，实验期中期末考试也是给出新文法进行实现。**还有就是建议各种文档要认真对待完成，不要太随意。**

### **2. 实验期末考试**

期末考试一共占实验部分的25分，10分新文法，10分课下强测和竞速，5分简答题（像给出一段代码问你的编译器是如何优化的等）

如果平时课下借鉴较多，强烈建议期末考试之前刷一下往年的期末题，不要只是熟悉代码。

#### 2024期末考试

新增2条文法：

* `Stmt → 'if' '(' BType Ident '=' InitVal ')' Stmt [ 'else' Stmt ]`

  即将原先的 `cond` 变为 `BType Ident '=' InitVal`

* `UnaryOp → '+' | '-' | '!' | '++'`

  新增单目运算符 `++`

对于第一条文法，给出以下例子：

```c
if(int a = 1){
	stmt1...
}
else{
	stmt2...
}
```

上述代码等价于：

```c
{
	int a = 1;
	if(a){
		stmt1...
	}
	else{
		stmt2...
	}
}
```

重点在于语义分析中对作用域的判断

对于第二条文法，给出以下例子：

```c
int a = 0;
if(++a){
	printf("%d\n", a); // 输出0
}
```

即 `++a` 等价于 `a+1`，但是并不改变原先 `a` 的值

#### 2023年期末考试

期末考试题目为增加两条文法：

- ` ForStmt → BType Ident '=' InitVal`.

  即在**for循环头处声明并初始化变量**的效果，例如`for(int i = 1;;)`。这里声明的变量作用域应当为这个for循环。

- `MulExp → MulExp ('*' | '/' | '%' | '**') UnaryExp`。

  我们把`MulExp`记为`a`，把`UnaryExp`记为`b`，则有规定：

  - 算符`**`的效果是`(a+b)**b`
  - 保证`b`一定是常数

对于第一条文法，请注意新声明的变量的作用域（例如建立符号表的时机，新符号加入符号表的时机）。

对于第二条文法，题目里b是常量，直接在编译器里取出来常量`b`的值，生成b条乘法中间代码即可。如果b不是常量，可以考虑手动生成一个for循环，结合对于` 'for' '(' [ForStmt] ';' [Cond] ';' [forStmt] ')' Stmt`翻译为中间代码的实现，略加修改即可。

#### 2022年期末考试

相对来说比较友好的题目。

- 新增文法：
  - VarDef → Ident `=` `getint``(``)`
- 修改文法：**按位与 `bitand`**
  - MulExp → UnaryExp | MulExp (`*`|`/`|`%`| **`bitand`** ) UnaryExp

变量定义时，**只可能** 是一个普通int变量定义，不会出现数组变量赋值，如`int a[10] = getint();`这种情况。

按位与的运算符号 **&** 被替换为了关键字 **bitand** 。**特别注意**其运算优先级与 **乘除模** 同级，与C/Java 不同。例如 **a + b bitand c \* d** 的中间代码为

```
t1 = b bitand c
t2 = t1 * d
t3 = a + t2
```

- **常量表达式 `ConstExp`** 的计算中不会出现按位与运算，例如 **const int p = N bitand M** 和 **int a[N bitand M]** （其中M和N为常量）这些是不合法的。
- 新增语法规则中，bitand为**保留关键字**，即测试样例不会出现 **ident为bitand** 的情况。
- **int i=getint();** 等价于 **int i; 与 i=getint();** 两条语句。
- **a bitand b** 运算效果等价于C/Java中的 **a & b** 。
- 提示：按位与运算可以用 **`and`** 指令实现，其格式与 **`add`** 等指令相同。