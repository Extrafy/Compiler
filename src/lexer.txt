CONSTTK const
INTTK int
IDENFR CONST_A
ASSIGN =
INTCON 10
COMMA ,
IDENFR CONST_B
ASSIGN =
INTCON 20
SEMICN ;
INTTK int
IDENFR CONST_ARR
LBRACK [
INTCON 3
RBRACK ]
ASSIGN =
LBRACE {
INTCON 1
COMMA ,
INTCON 2
COMMA ,
INTCON 3
RBRACE }
SEMICN ;
INTTK int
IDENFR g_x
COMMA ,
IDENFR g_y
ASSIGN =
INTCON 5
COMMA ,
IDENFR g_arr
LBRACK [
INTCON 4
RBRACK ]
ASSIGN =
LBRACE {
INTCON 4
COMMA ,
INTCON 3
COMMA ,
INTCON 2
COMMA ,
INTCON 1
RBRACE }
SEMICN ;
VOIDTK void
IDENFR voidFunc
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR a
ASSIGN =
IDENFR CONST_A
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "voidFunc: a = %d\n"
COMMA ,
IDENFR a
RPARENT )
SEMICN ;
RBRACE }
INTTK int
IDENFR sumAndMax
LPARENT (
INTTK int
IDENFR n
COMMA ,
INTTK int
IDENFR arr
LBRACK [
RBRACK ]
RPARENT )
LBRACE {
INTTK int
IDENFR sum
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR mx
ASSIGN =
IDENFR arr
LBRACK [
INTCON 0
RBRACK ]
SEMICN ;
INTTK int
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
FORTK for
LPARENT (
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
IDENFR i
LSS <
IDENFR n
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
IDENFR sum
ASSIGN =
IDENFR sum
PLUS +
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
SEMICN ;
IFTK if
LPARENT (
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
GRE >
IDENFR mx
RPARENT )
IDENFR mx
ASSIGN =
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
SEMICN ;
RBRACE }
RETURNTK return
IDENFR sum
PLUS +
IDENFR mx
SEMICN ;
RBRACE }
INTTK int
IDENFR fib
LPARENT (
INTTK int
IDENFR n
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR n
LEQ <=
INTCON 1
RPARENT )
RETURNTK return
IDENFR n
SEMICN ;
RETURNTK return
IDENFR fib
LPARENT (
IDENFR n
MINU -
INTCON 1
RPARENT )
PLUS +
IDENFR fib
LPARENT (
IDENFR n
MINU -
INTCON 2
RPARENT )
SEMICN ;
RBRACE }
VOIDTK void
IDENFR caller
LPARENT (
RPARENT )
LBRACE {
IDENFR voidFunc
LPARENT (
RPARENT )
SEMICN ;
INTTK int
IDENFR result
ASSIGN =
IDENFR sumAndMax
LPARENT (
INTCON 3
COMMA ,
IDENFR CONST_ARR
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "caller: result=%d\n"
COMMA ,
IDENFR result
RPARENT )
SEMICN ;
RBRACE }
INTTK int
MAINTK main
LPARENT (
RPARENT )
LBRACE {
STATICTK static
INTTK int
IDENFR g_static
ASSIGN =
INTCON 100
SEMICN ;
INTTK int
IDENFR i
COMMA ,
IDENFR j
SEMICN ;
CONSTTK const
INTTK int
IDENFR LOCAL_CONST
ASSIGN =
INTCON 99
SEMICN ;
IDENFR i
ASSIGN =
INTCON 1
SEMICN ;
IDENFR j
ASSIGN =
IDENFR i
MULT *
INTCON 2
PLUS +
LPARENT (
IDENFR i
MINU -
INTCON 3
RPARENT )
MOD %
INTCON 2
SEMICN ;
IDENFR j
PLUS +
INTCON 5
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "i=%d, j=%d\n"
COMMA ,
IDENFR i
COMMA ,
IDENFR j
RPARENT )
SEMICN ;
IFTK if
LPARENT (
IDENFR i
LSS <
IDENFR j
AND &&
IDENFR j
NEQ !=
INTCON 0
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "i<j && j!=0\n"
RPARENT )
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "else branch\n"
RPARENT )
SEMICN ;
RBRACE }
LBRACE {
INTTK int
IDENFR tmp
ASSIGN =
IDENFR j
DIV /
LPARENT (
IDENFR i
PLUS +
INTCON 1
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "tmp=%d\n"
COMMA ,
IDENFR tmp
RPARENT )
SEMICN ;
RBRACE }
INTTK int
IDENFR k
SEMICN ;
FORTK for
LPARENT (
IDENFR k
ASSIGN =
INTCON 0
SEMICN ;
IDENFR k
LSS <
INTCON 3
SEMICN ;
IDENFR k
ASSIGN =
IDENFR k
PLUS +
INTCON 1
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "full for k=%d\n"
COMMA ,
IDENFR k
RPARENT )
SEMICN ;
RBRACE }
IDENFR k
ASSIGN =
INTCON 0
SEMICN ;
FORTK for
LPARENT (
SEMICN ;
IDENFR k
LSS <
INTCON 2
SEMICN ;
IDENFR k
ASSIGN =
IDENFR k
PLUS +
INTCON 2
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "no init for k=%d\n"
COMMA ,
IDENFR k
RPARENT )
SEMICN ;
RBRACE }
FORTK for
LPARENT (
IDENFR k
ASSIGN =
INTCON 0
SEMICN ;
SEMICN ;
IDENFR k
ASSIGN =
IDENFR k
PLUS +
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR k
GRE >
INTCON 1
RPARENT )
BREAKTK break
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "no cond k=%d\n"
COMMA ,
IDENFR k
RPARENT )
SEMICN ;
RBRACE }
FORTK for
LPARENT (
IDENFR k
ASSIGN =
INTCON 0
SEMICN ;
IDENFR k
LSS <
INTCON 2
SEMICN ;
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "no iter k=%d\n"
COMMA ,
IDENFR k
RPARENT )
SEMICN ;
IDENFR k
ASSIGN =
IDENFR k
PLUS +
INTCON 1
SEMICN ;
RBRACE }
IDENFR k
ASSIGN =
INTCON 0
SEMICN ;
FORTK for
LPARENT (
SEMICN ;
SEMICN ;
RPARENT )
LBRACE {
IDENFR k
ASSIGN =
IDENFR k
PLUS +
INTCON 1
SEMICN ;
IFTK if
LPARENT (
IDENFR k
GRE >
INTCON 0
RPARENT )
BREAKTK break
SEMICN ;
CONTINUETK continue
SEMICN ;
RBRACE }
INTTK int
IDENFR b
SEMICN ;
FORTK for
LPARENT (
IDENFR b
ASSIGN =
INTCON 0
SEMICN ;
IDENFR b
LSS <
INTCON 2
SEMICN ;
IDENFR b
ASSIGN =
IDENFR b
PLUS +
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR b
EQL ==
INTCON 0
RPARENT )
CONTINUETK continue
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "after continue, b=%d\n"
COMMA ,
IDENFR b
RPARENT )
SEMICN ;
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "End of main\n"
RPARENT )
SEMICN ;
IDENFR caller
LPARENT (
RPARENT )
SEMICN ;
INTTK int
IDENFR f5
ASSIGN =
IDENFR fib
LPARENT (
INTCON 5
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "fib(5) = %d\n"
COMMA ,
IDENFR f5
RPARENT )
SEMICN ;
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
